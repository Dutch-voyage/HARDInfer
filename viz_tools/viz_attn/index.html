<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Hypercube Matrix Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: white;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 240px;
            backdrop-filter: blur(5px);
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #4facfe #222;
        }
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        #controls::-webkit-scrollbar-track {
            background: #222;
        }
        #controls::-webkit-scrollbar-thumb {
            background-color: #4facfe;
            border-radius: 4px;
        }
        h1 {
            font-size: 16px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #4facfe;
            text-align: center;
        }
        .section-title {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-top: 15px;
            margin-bottom: 5px;
            border-bottom: 1px solid #444;
            padding-bottom: 2px;
        }
        .input-group {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        label {
            font-size: 14px;
            color: #ccc;
            font-weight: 500;
        }
        input[type="number"] {
            width: 50px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: white;
            text-align: center;
            font-weight: bold;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #4facfe;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
        }
        input[type="range"]:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        select {
            width: 100%;
            padding: 5px;
            background: #222;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        input[type="color"] {
            background: none;
            border: none;
            width: 40px;
            height: 30px;
            cursor: pointer;
        }
        button {
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
            transition: background 0.2s;
        }
        button:hover {
            background: #444;
            border-color: #4facfe;
        }
        .info {
            margin-top: 15px;
            font-size: 12px;
            color: #888;
            text-align: center;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        #total-count {
            color: #4facfe;
            font-weight: bold;
        }
        
        /* Mode Specific Controls */
        .mode-controls {
            display: none;
            border-left: 2px solid #444;
            padding-left: 10px;
            margin-bottom: 10px;
        }
        .mode-controls.active {
            display: block;
        }
        
        /* Stepper styles */
        .stepper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 5px;
        }
        .stepper button {
            margin: 0;
            width: 40px;
            font-weight: bold;
        }
        
        .dims-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        /* Checkbox wrapper */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #ccc;
            width: 100%;
        }
        .checkbox-wrapper input {
            cursor: pointer;
        }
        
        /* File Input */
        input[type="file"] {
            font-size: 11px;
            color: #ccc;
            width: 100%;
            margin-top: 5px;
        }
        
        /* Drag Drop Overlay */
        #dropOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            pointer-events: none;
        }
        #dropOverlay.active {
            display: flex;
        }
        .drop-message {
            border: 2px dashed #4facfe;
            padding: 40px;
            border-radius: 20px;
            font-size: 24px;
            color: #4facfe;
            background: rgba(0,0,0,0.8);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/addons/"
            }
        }
    </script>
</head>
<body>

    <div id="dropOverlay">
        <div class="drop-message">Drop JSON File Here</div>
    </div>

    <div id="controls">
        <h1>4D Cube Matrix</h1>
        <div style="display:flex; gap:5px; margin-bottom: 15px;">
            <button id="resetCamBtn" style="flex:2; margin-top:0; border-color: #555;">Reset Camera</button>
            <button id="zoomInBtn" style="flex:1; margin-top:0; border-color: #555; font-weight:bold;">+</button>
            <button id="zoomOutBtn" style="flex:1; margin-top:0; border-color: #555; font-weight:bold;">-</button>
        </div>
        
        <div class="section-title">Import Data</div>
        <div class="input-group" style="flex-direction:column; align-items:stretch;">
            <!-- Hidden Input -->
            <input type="file" id="fileInput" accept=".json" style="display:none;">
            
            <!-- Custom Button -->
            <button id="chooseFileBtn" style="background:#444; margin-bottom:5px;">ðŸ“‚ Choose Data File (JSON)</button>
            <div id="fileNameDisplay" style="font-size:11px; color:#aaa; margin-bottom:5px; font-style:italic; text-align:center;">No file selected</div>
            
            <!-- URL Loader -->
            <div style="margin-bottom:5px; border-top:1px solid #444; padding-top:5px;">
                <div style="font-size:11px; color:#aaa; margin-bottom:3px;">Load from Server/URL:</div>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="urlInput" placeholder="e.g. ./data.json" style="width:100%; font-size:11px; padding:4px; background:#222; border:1px solid #444; color:white;">
                    <button id="loadUrlBtn" style="padding:4px; font-size:11px; width:50px; background:#333; border:1px solid #555;">Load</button>
                </div>
            </div>

            <div style="display:flex; gap:5px;">
                <button id="dlTemplateBtn" style="font-size:11px; padding:4px; flex:1;">Template</button>
                <button id="resetDataBtn" style="display:none; font-size:11px; padding:4px; background:#553333; border-color:#884444; flex:1;">Reset</button>
            </div>
        </div>

        <div class="section-title">Data Configuration</div>
        
        <div class="input-group">
            <label for="dimD" style="color:#4facfe; width:100%;">D (Total Hyper-Slices)</label>
            <input type="number" id="dimD" value="3" min="1" max="10000" style="border-color:#4facfe; width:100%;">
        </div>
        
        <div style="font-size:11px; color:#666; margin-bottom:5px;">Define A, B, C for D-Slice #<span id="configWIdxDisplay">0</span>:</div>
        <div class="dims-container">
            <div class="input-group">
                <label for="dimA">A</label>
                <input type="number" id="dimA" value="10" min="1" max="10000">
            </div>
            <div class="input-group">
                <label for="dimB">B</label>
                <input type="number" id="dimB" value="5" min="1" max="10000">
            </div>
            <div class="input-group">
                <label for="dimC">C</label>
                <input type="number" id="dimC" value="5" min="1" max="10000">
            </div>
        </div>

        <div class="section-title" style="color:#4facfe">Visualization Scan</div>
        
        <div class="input-group">
            <label for="scanAxis">Scan Axis</label>
            <select id="scanAxis" style="margin-bottom:0; width:80px;">
                <option value="d" selected>D (Hyper)</option>
                <option value="a">A (Width)</option>
                <option value="b">B (Height)</option>
                <option value="c">C (Depth)</option>
            </select>
        </div>

        <div class="input-group" style="flex-direction: column; align-items: flex-start;">
            <label id="scanIndexLabel" style="margin-bottom: 5px; width:100%;">Scan Index (D)</label>
            <div class="stepper">
                <button id="prevScanBtn">&lt;</button>
                <input type="number" id="scanIndex" value="0" min="0" style="text-align:center; flex-grow:1; margin:0;">
                <button id="nextScanBtn">&gt;</button>
            </div>
        </div>

        <!-- NEW: Axis Mapping -->
        <div class="input-group">
            <label for="axisMap">Axis Map (X-Y-Z)</label>
            <select id="axisMap" style="margin-bottom:0; width:90px;">
                <option value="012" selected>1 - 2 - 3 (Def)</option>
                <option value="021">1 - 3 - 2</option>
                <option value="102">2 - 1 - 3</option>
                <option value="120">2 - 3 - 1</option>
                <option value="201">3 - 1 - 2</option>
                <option value="210">3 - 2 - 1</option>
            </select>
        </div>
        <div id="axisLegend" style="font-size:11px; color:#4facfe; text-align:center; margin-bottom:10px;">
            X: A, Y: B, Z: C
        </div>

        <div class="section-title">View Mode (3D Slice)</div>
        <select id="viewMode">
            <option value="3d" selected>Full 3D Block</option>
            <option value="2d">2D Slice</option>
        </select>

        <div id="sliceSettings" class="mode-controls">
            <div class="input-group">
                <label for="sliceAxis">Axis</label>
                <select id="sliceAxis" style="margin-bottom:0; width:60px;">
                    <option value="x">Vis X</option>
                    <option value="y">Vis Y</option>
                    <option value="z">Vis Z</option>
                </select>
            </div>
            
            <div class="input-group" style="flex-direction: column; align-items: flex-start;">
                <label style="margin-bottom: 5px; width:100%;">2D Slice Index</label>
                <div class="stepper">
                    <button id="prevSliceBtn">&lt;</button>
                    <input type="number" id="sliceIndex" value="0" min="0" style="text-align:center; flex-grow:1; margin:0;">
                    <button id="nextSliceBtn">&gt;</button>
                </div>
            </div>

            <div class="checkbox-wrapper" style="margin-top:8px; border-top:1px solid #333; padding-top:8px;">
                <input type="checkbox" id="meanProjection">
                <label for="meanProjection" style="color:#00ffcc; margin:0; cursor:pointer;">Project Mean Value (Binary)</label>
            </div>

            <button id="snapCameraBtn">Snap Camera to View</button>
            <button id="exportSliceBtn" style="margin-top: 5px; background: #2a2a2a; border-color: #555;">Export PNG</button>
        </div>

        <div class="section-title">Data Mode</div>
        <select id="colorMode">
            <option value="rgb">Coordinate RGB</option>
            <option value="continuous">Continuous 4D Field</option>
            <option value="binary" selected>Binary (0/1)</option>
        </select>

        <!-- Continuous Controls -->
        <div id="continuousSettings" class="mode-controls">
            <div class="input-group" style="display:block;">
                <label for="pattern">Pattern Function</label>
                <select id="pattern">
                    <option value="linear">Linear (4D Diagonal)</option>
                    <option value="radial">Radial (4D Sphere)</option>
                    <option value="ripple">4D Ripple</option>
                    <option value="random">Random Noise</option>
                </select>
            </div>
            <div class="input-group">
                <label for="contLow">Low Value</label>
                <input type="color" id="contLow" value="#000044">
            </div>
            <div class="input-group">
                <label for="contHigh">High Value</label>
                <input type="color" id="contHigh" value="#00ffff">
            </div>
        </div>

        <!-- Binary Controls -->
        <div id="binarySettings" class="mode-controls active">
            <div class="input-group">
                <label for="color0">0 Color</label>
                <input type="color" id="color0" value="#94becf">
            </div>
            <div class="input-group">
                <label for="color1">1 Color</label>
                <input type="color" id="color1" value="#ff3b3b">
            </div>
            <div class="input-group" style="display:block;">
                <label for="density">Density (Generator)</label>
                <input type="range" id="density" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div class="checkbox-wrapper" style="margin-top:5px; border-top:1px solid #444; padding-top:5px;">
                <input type="checkbox" id="binaryGradient">
                <label for="binaryGradient" style="color:#ddd; margin:0; cursor:pointer;">Visualize Real Values (Gradient)</label>
            </div>
        </div>

        <div class="section-title">Appearance</div>
        <div class="input-group">
            <div style="display:flex; align-items:center; gap:8px;">
                <input type="checkbox" id="forceCubic" checked>
                <label for="forceCubic" style="margin:0; cursor:pointer; font-size:13px; font-weight:normal; color:white;">Constrain Ratio</label>
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label for="maxRatio" style="font-size:12px; margin:0;">Max:</label>
                <input type="number" id="maxRatio" value="10" min="1" max="100" style="width:40px; padding:2px; text-align:center;">
            </div>
        </div>
        <div class="checkbox-wrapper" style="margin-bottom:8px;">
            <input type="checkbox" id="showOrigin">
            <label for="showOrigin" style="color:#ddd; margin:0; cursor:pointer;">Mark Origin (0,0,0)</label>
        </div>
        <div class="input-group">
            <label for="cubeScale">Cube Scale</label>
            <div style="display:flex; align-items:center; gap:10px; flex-grow:1; justify-content:flex-end;">
                <label style="font-size:11px; cursor:pointer; color:#4facfe; user-select:none;">
                    <input type="checkbox" id="autoScale"> Auto
                </label>
                <input type="range" id="cubeScale" min="0.05" max="1" step="0.05" value="1" style="width:70px; margin:0;">
            </div>
        </div>

        <div class="info">
            Visualized Cubes: <span id="visual-count">125</span><br>
            Total 4D Data Points: <span id="total-count">375</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // Variables
        let mesh;
        let originHelper;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // DOM Elements
        const inputA = document.getElementById('dimA');
        const inputB = document.getElementById('dimB');
        const inputC = document.getElementById('dimC');
        const inputD = document.getElementById('dimD');
        const configWIdxDisplay = document.getElementById('configWIdxDisplay');
        
        const fileInput = document.getElementById('fileInput');
        const chooseFileBtn = document.getElementById('chooseFileBtn');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const dropOverlay = document.getElementById('dropOverlay');
        const dlTemplateBtn = document.getElementById('dlTemplateBtn');
        const resetDataBtn = document.getElementById('resetDataBtn');
        
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');

        const inputScale = document.getElementById('cubeScale');
        const autoScaleCheckbox = document.getElementById('autoScale');
        const forceCubicCheckbox = document.getElementById('forceCubic');
        const maxRatioInput = document.getElementById('maxRatio');
        const showOriginCheckbox = document.getElementById('showOrigin');
        
        const viewModeSelect = document.getElementById('viewMode');
        const colorModeSelect = document.getElementById('colorMode');
        
        const scanAxisSelect = document.getElementById('scanAxis');
        const scanIndexInput = document.getElementById('scanIndex');
        const scanIndexLabel = document.getElementById('scanIndexLabel');
        const prevScanBtn = document.getElementById('prevScanBtn');
        const nextScanBtn = document.getElementById('nextScanBtn');
        const axisMapSelect = document.getElementById('axisMap');
        const axisLegend = document.getElementById('axisLegend');

        const sliceSettings = document.getElementById('sliceSettings');
        const sliceAxisSelect = document.getElementById('sliceAxis');
        const sliceIndexInput = document.getElementById('sliceIndex');
        const prevSliceBtn = document.getElementById('prevSliceBtn');
        const nextSliceBtn = document.getElementById('nextSliceBtn');
        const meanProjectionCheckbox = document.getElementById('meanProjection');
        const snapCameraBtn = document.getElementById('snapCameraBtn');
        const resetCamBtn = document.getElementById('resetCamBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const exportSliceBtn = document.getElementById('exportSliceBtn');

        const contSettings = document.getElementById('continuousSettings');
        const patternSelect = document.getElementById('pattern');
        const inputContLow = document.getElementById('contLow');
        const inputContHigh = document.getElementById('contHigh');

        const binarySettings = document.getElementById('binarySettings');
        const inputColor0 = document.getElementById('color0');
        const inputColor1 = document.getElementById('color1');
        const inputDensity = document.getElementById('density');
        const binaryGradientCheckbox = document.getElementById('binaryGradient');
        
        const totalCountSpan = document.getElementById('total-count');
        const visualCountSpan = document.getElementById('visual-count');

        // --- DATA STRUCTURE ---
        let cubesConfig = [];
        let lastPattern = '';
        let dataLoadedFromFile = false; 

        initializeConfig(3); 

        function initializeConfig(dSize) {
            if (dataLoadedFromFile && dSize !== cubesConfig.length) {
                // reset if conflict
            }

            if (dSize > cubesConfig.length) {
                for (let i = cubesConfig.length; i < dSize; i++) {
                    let dims = { a: 10, b: 5, c: 5 };
                    if (i > 0) {
                        dims = { 
                            a: cubesConfig[i-1].a, 
                            b: cubesConfig[i-1].b, 
                            c: cubesConfig[i-1].c 
                        };
                    }
                    cubesConfig.push({
                        a: dims.a,
                        b: dims.b,
                        c: dims.c,
                        data: new Float32Array(dims.a * dims.b * dims.c) 
                    });
                }
            } else if (dSize < cubesConfig.length) {
                cubesConfig.length = dSize;
            }
            regenerateAllData();
        }

        function regenerateAllData() {
            if (dataLoadedFromFile) return;

            const mode = colorModeSelect.value;
            const pattern = patternSelect.value;
            const density = parseFloat(inputDensity.value);
            const d = cubesConfig.length;
            const maxSum = 100;

            cubesConfig.forEach((slice, w) => {
                const { a, b, c } = slice;
                const total = a * b * c;
                if (slice.data.length !== total) {
                    slice.data = new Float32Array(total);
                }

                const cx = (a - 1) / 2;
                const cy = (b - 1) / 2;
                const cz = (c - 1) / 2;
                const cw = (d - 1) / 2;
                const maxRadius = Math.sqrt(cx*cx + cy*cy + cz*cz + cw*cw) || 1;
                const pMaxSum = (a + b + c + d) || 1;

                if (mode === 'binary') {
                    for (let i = 0; i < total; i++) {
                        slice.data[i] = Math.random() < density ? 1 : 0;
                    }
                } else if (mode === 'continuous') {
                    let i = 0;
                    for (let x = 0; x < a; x++) {
                        for (let y = 0; y < b; y++) {
                            for (let z = 0; z < c; z++) {
                                let val = 0;
                                if (pattern === 'linear') {
                                    val = (x + y + z + w) / pMaxSum;
                                } else if (pattern === 'radial') {
                                    const dist = Math.sqrt(Math.pow(x-cx,2) + Math.pow(y-cy,2) + Math.pow(z-cz,2) + Math.pow(w-cw,2));
                                    val = 1 - (dist / maxRadius);
                                    if(val < 0) val = 0;
                                } else if (pattern === 'ripple') {
                                    const dist = Math.sqrt(Math.pow(x-cx,2) + Math.pow(y-cy,2) + Math.pow(z-cz,2) + Math.pow(w-cw,2));
                                    val = 0.5 + 0.5 * Math.sin(dist * 0.8);
                                } else if (pattern === 'random') {
                                    val = Math.random();
                                }
                                slice.data[i] = val;
                                i++;
                            }
                        }
                    }
                }
            });
            lastPattern = pattern;
        }

        function getData(a, b, c, d) {
            if (d < 0 || d >= cubesConfig.length) return -1;
            const slice = cubesConfig[d];
            if (a < 0 || a >= slice.a) return -1;
            if (b < 0 || b >= slice.b) return -1;
            if (c < 0 || c >= slice.c) return -1;
            return slice.data[a * (slice.b * slice.c) + b * slice.c + c];
        }

        // Helpers
        function getBaseAxes(scanAx) {
            if (scanAx === 'd') return ['A', 'B', 'C'];
            if (scanAx === 'a') return ['D', 'B', 'C'];
            if (scanAx === 'b') return ['D', 'A', 'C'];
            if (scanAx === 'c') return ['D', 'A', 'B'];
            return ['A','B','C'];
        }

        function getPermutation() {
            const mapStr = axisMapSelect.value; 
            return [parseInt(mapStr[0]), parseInt(mapStr[1]), parseInt(mapStr[2])];
        }

        function updateUI() {
            // Color Mode UI
            const mode = colorModeSelect.value;
            if (mode === 'continuous') {
                contSettings.classList.add('active');
                binarySettings.classList.remove('active');
            } else if (mode === 'binary') {
                contSettings.classList.remove('active');
                binarySettings.classList.add('active');
            } else {
                contSettings.classList.remove('active');
                binarySettings.classList.remove('active');
            }

            inputDensity.disabled = dataLoadedFromFile;
            resetDataBtn.style.display = dataLoadedFromFile ? 'block' : 'none';

            // Scan Axis Logic
            const sAxis = scanAxisSelect.value;
            const baseAxes = getBaseAxes(sAxis);
            const P = getPermutation(); 
            
            axisLegend.innerText = `X: ${baseAxes[P[0]]}, Y: ${baseAxes[P[1]]}, Z: ${baseAxes[P[2]]}`;

            // Update Scan Index Limits
            let maxScan = 0;
            let gA=0,gB=0,gC=0,gD=cubesConfig.length;
            cubesConfig.forEach(s=>{ gA=Math.max(gA,s.a); gB=Math.max(gB,s.b); gC=Math.max(gC,s.c); });
            
            if (sAxis === 'd') maxScan = gD - 1;
            else if (sAxis === 'a') maxScan = gA - 1;
            else if (sAxis === 'b') maxScan = gB - 1;
            else if (sAxis === 'c') maxScan = gC - 1;
            
            scanIndexInput.max = maxScan;
            if(parseInt(scanIndexInput.value) > maxScan) scanIndexInput.value = maxScan;
            
            scanIndexLabel.innerText = `Scan Index (${sAxis.toUpperCase()})`;

            // View Mode UI
            const viewMode = viewModeSelect.value;
            
            // Map dims to indices 0,1,2 for slider
            let dim0=0, dim1=0, dim2=0;
            if (sAxis === 'd') {
                const w = parseInt(scanIndexInput.value) || 0;
                const s = cubesConfig[w] || {a:1,b:1,c:1};
                dim0 = s.a; dim1 = s.b; dim2 = s.c;
            } else {
                if(sAxis==='a') { dim0=gD; dim1=gB; dim2=gC; }
                else if(sAxis==='b') { dim0=gD; dim1=gA; dim2=gC; }
                else if(sAxis==='c') { dim0=gD; dim1=gA; dim2=gB; }
            }

            // Permute
            let visDims = [0,0,0];
            let baseD = [dim0, dim1, dim2];
            visDims[0] = baseD[P[0]];
            visDims[1] = baseD[P[1]];
            visDims[2] = baseD[P[2]];

            if (viewMode === '2d') {
                sliceSettings.classList.add('active');
                const axis = sliceAxisSelect.value;
                let maxVal = 0;
                if(axis === 'x') maxVal = visDims[0] - 1;
                if(axis === 'y') maxVal = visDims[1] - 1;
                if(axis === 'z') maxVal = visDims[2] - 1;
                
                sliceIndexInput.max = maxVal;
                if(parseInt(sliceIndexInput.value) > maxVal) {
                    sliceIndexInput.value = maxVal;
                }
                controls.autoRotate = false;
            } else {
                sliceSettings.classList.remove('active');
            }
        }

        function determineOptimalScale(a, b, c) {
            const maxDim = Math.max(a, b, c);
            let scale = 0.9 - (maxDim - 5) * 0.016; 
            return Math.max(0.15, Math.min(0.95, scale));
        }

        function updateCubes(forceRegen = false) {
            const d = parseInt(inputD.value) || 1;
            if (!dataLoadedFromFile && d !== cubesConfig.length) {
                initializeConfig(d);
                forceRegen = false; 
            } else if (dataLoadedFromFile && d !== cubesConfig.length) {
                dataLoadedFromFile = false; 
                initializeConfig(d);
                fileNameDisplay.innerText = "Modified (No file)";
            }

            const sAxis = scanAxisSelect.value;
            let configDIdx = 0;
            if (sAxis === 'd') {
                configDIdx = parseInt(scanIndexInput.value) || 0;
            } 
            
            if (configDIdx >= 0 && configDIdx < cubesConfig.length) {
                configWIdxDisplay.innerText = configDIdx;
                if (sAxis === 'd') {
                    const a = parseInt(inputA.value) || 1;
                    const b = parseInt(inputB.value) || 1;
                    const c = parseInt(inputC.value) || 1;
                    const currentSlice = cubesConfig[configDIdx];
                    
                    if (currentSlice.a !== a || currentSlice.b !== b || currentSlice.c !== c) {
                        currentSlice.a = a;
                        currentSlice.b = b;
                        currentSlice.c = c;
                        forceRegen = true; 
                        if (dataLoadedFromFile) {
                            dataLoadedFromFile = false; 
                            fileNameDisplay.innerText = "Modified (No file)";
                        }
                    }
                }
            }

            updateUI();

            const scaleVal = parseFloat(inputScale.value);
            const mode = colorModeSelect.value;
            const pattern = patternSelect.value;
            const viewMode = viewModeSelect.value;
            const constrainRatio = forceCubicCheckbox.checked;
            const maxRatioVal = parseFloat(maxRatioInput.value) || 10;
            const useMeanProj = meanProjectionCheckbox.checked;
            const useBinaryGradient = binaryGradientCheckbox.checked;

            let needsRegen = forceRegen;
            if (!dataLoadedFromFile) {
                if (mode === 'continuous' && pattern !== lastPattern) needsRegen = true;
            }

            if (needsRegen && !dataLoadedFromFile) {
                regenerateAllData();
            }

            const scanIdx = parseInt(scanIndexInput.value) || 0;
            
            let vDimX = 0, vDimY = 0, vDimZ = 0;
            let gA=0,gB=0,gC=0,gD=cubesConfig.length;
            cubesConfig.forEach(s=>{ gA=Math.max(gA,s.a); gB=Math.max(gB,s.b); gC=Math.max(gC,s.c); });

            let baseDims = [];
            if(sAxis==='d') {
                const s = cubesConfig[scanIdx] || {a:1,b:1,c:1};
                baseDims = [s.a, s.b, s.c];
            }
            else if(sAxis==='a') baseDims=[gD, gB, gC];
            else if(sAxis==='b') baseDims=[gD, gA, gC];
            else if(sAxis==='c') baseDims=[gD, gA, gB];

            const P = getPermutation(); 
            vDimX = baseDims[P[0]];
            vDimY = baseDims[P[1]];
            vDimZ = baseDims[P[2]];

            const visualTotal = vDimX * vDimY * vDimZ;
            
            if (mesh) {
                scene.remove(mesh);
                mesh.dispose();
            }

            mesh = new THREE.InstancedMesh(geometry, material, visualTotal);
            mesh.frustumCulled = false;
            
            const offsetX = (vDimX - 1) / 2;
            const offsetY = (vDimY - 1) / 2;
            const offsetZ = (vDimZ - 1) / 2;

            let stepX = 1, stepY = 1, stepZ = 1;
            if (constrainRatio) {
                const maxDim = Math.max(vDimX, vDimY, vDimZ);
                const minAllowed = maxDim / maxRatioVal;
                if (vDimX < minAllowed) stepX = minAllowed / vDimX;
                if (vDimY < minAllowed) stepY = minAllowed / vDimY;
                if (vDimZ < minAllowed) stepZ = minAllowed / vDimZ;
            }

            if (originHelper) {
                scene.remove(originHelper);
                originHelper = null; 
            }

            if (showOriginCheckbox.checked) {
                originHelper = new THREE.Group();
                const axisSize = Math.max(stepX, stepY, stepZ) * 2;
                const axes = new THREE.AxesHelper(axisSize);
                originHelper.add(axes);
                const boxW = (scaleVal * stepX) || 0.1;
                const boxH = (scaleVal * stepY) || 0.1;
                const boxD = (scaleVal * stepZ) || 0.1;
                const padding = 1.25; 
                const boxGeo = new THREE.BoxGeometry(boxW * padding, boxH * padding, boxD * padding);
                const edges = new THREE.EdgesGeometry(boxGeo);
                const boxMat = new THREE.LineBasicMaterial({ color: 0xffff00 });
                const boxWireframe = new THREE.LineSegments(edges, boxMat);
                originHelper.add(boxWireframe);

                const px = (0 - offsetX) * stepX;
                const py = (0 - offsetY) * stepY;
                const pz = (0 - offsetZ) * stepZ;
                originHelper.position.set(px, py, pz);
                scene.add(originHelper);
            }

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            
            const cLow = new THREE.Color(inputContLow.value);
            const cHigh = new THREE.Color(inputContHigh.value);
            const b0 = new THREE.Color(inputColor0.value);
            const b1 = new THREE.Color(inputColor1.value);

            if (autoScaleCheckbox.checked && sAxis === 'd') {
               inputScale.value = determineOptimalScale(vDimX, vDimY, vDimZ);
            }

            const sliceAxis = sliceAxisSelect.value;
            const sliceIdx = parseInt(sliceIndexInput.value);
            
            let instanceIdx = 0;

            for (let x = 0; x < vDimX; x++) {
                for (let y = 0; y < vDimY; y++) {
                    for (let z = 0; z < vDimZ; z++) {
                        
                        let isVisible = true;
                        if (viewMode === '2d') {
                            if (sliceAxis === 'x' && x !== sliceIdx) isVisible = false;
                            if (sliceAxis === 'y' && y !== sliceIdx) isVisible = false;
                            if (sliceAxis === 'z' && z !== sliceIdx) isVisible = false;
                        }

                        let baseCoords = [0,0,0];
                        baseCoords[P[0]] = x;
                        baseCoords[P[1]] = y;
                        baseCoords[P[2]] = z;

                        let val = 0;
                        let exists = false;

                        const getReal = (b0, b1, b2) => {
                            let ra, rb, rc, rd;
                            if (sAxis === 'd') { ra=b0; rb=b1; rc=b2; rd=scanIdx; }
                            else if (sAxis === 'a') { ra=scanIdx; rb=b1; rc=b2; rd=b0; }
                            else if (sAxis === 'b') { ra=b1; rb=scanIdx; rc=b2; rd=b0; }
                            else if (sAxis === 'c') { ra=b1; rb=b2; rc=scanIdx; rd=b0; }
                            return {ra, rb, rc, rd};
                        };

                        if (isVisible) {
                            if (viewMode === '2d' && useMeanProj && mode === 'binary') {
                                let sum = 0;
                                let count = 0;
                                
                                let loopStart=0, loopEnd=0;
                                if(sliceAxis==='x') { loopEnd = vDimX; }
                                else if(sliceAxis==='y') { loopEnd = vDimY; }
                                else if(sliceAxis==='z') { loopEnd = vDimZ; }
                                
                                for(let k=loopStart; k<loopEnd; k++) {
                                    let tx=x, ty=y, tz=z;
                                    if(sliceAxis==='x') tx=k;
                                    else if(sliceAxis==='y') ty=k;
                                    else if(sliceAxis==='z') tz=k;
                                    
                                    let tBase = [0,0,0];
                                    tBase[P[0]] = tx;
                                    tBase[P[1]] = ty;
                                    tBase[P[2]] = tz;
                                    
                                    let r = getReal(tBase[0], tBase[1], tBase[2]);
                                    let v = getData(r.ra, r.rb, r.rc, r.rd);
                                    if(v !== -1) { sum += v; count++; }
                                }
                                
                                if (count > 0) { val = sum / count; exists = true; }

                            } else {
                                let r = getReal(baseCoords[0], baseCoords[1], baseCoords[2]);
                                val = getData(r.ra, r.rb, r.rc, r.rd);
                                exists = (val !== -1);
                            }
                        }

                        if (isVisible && exists) {
                            dummy.position.set(
                                (x - offsetX) * stepX, 
                                (y - offsetY) * stepY, 
                                (z - offsetZ) * stepZ
                            );
                            dummy.scale.set(scaleVal * stepX, scaleVal * stepY, scaleVal * stepZ);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(instanceIdx, dummy.matrix);

                            if (mode === 'rgb') {
                                const r = x / Math.max(vDimX - 1, 1);
                                const g = y / Math.max(vDimY - 1, 1);
                                const bl = z / Math.max(vDimZ - 1, 1);
                                color.setRGB(0.2 + r * 0.8, 0.2 + g * 0.8, 0.5 + bl * 0.5);
                            } 
                            else if (mode === 'binary') {
                                if ((useMeanProj && viewMode === '2d') || useBinaryGradient) {
                                     color.copy(b0).lerp(b1, val);
                                } else {
                                     color.copy(val >= 0.5 ? b1 : b0);
                                }
                            } 
                            else if (mode === 'continuous') {
                                color.copy(cLow).lerp(cHigh, val);
                            }
                            mesh.setColorAt(instanceIdx, color);
                        } else {
                            dummy.position.set(0,0,0);
                            dummy.scale.set(0,0,0);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(instanceIdx, dummy.matrix);
                        }
                        instanceIdx++;
                    }
                }
            }

            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            scene.add(mesh);
            
            let totalPoints = 0;
            cubesConfig.forEach(s => totalPoints += s.data.length);
            totalCountSpan.innerText = totalPoints.toLocaleString();
            visualCountSpan.innerText = visualTotal.toLocaleString();
        }

        // --- Event Listeners ---
        inputD.addEventListener('input', () => updateCubes(false));
        
        function onInputDimChange() {
            if (scanAxisSelect.value === 'd') {
                updateCubes(false);
                if (viewModeSelect.value === '2d') snapCamera();
            }
        }
        [inputA, inputB, inputC].forEach(el => el.addEventListener('input', onInputDimChange));

        function onScanChange() {
            if (scanAxisSelect.value === 'd') {
                 const w = parseInt(scanIndexInput.value) || 0;
                 if (cubesConfig[w]) {
                     inputA.value = cubesConfig[w].a;
                     inputB.value = cubesConfig[w].b;
                     inputC.value = cubesConfig[w].c;
                 }
            }
            updateCubes(false);
            if (viewModeSelect.value === '2d') snapCamera();
        }
        
        scanAxisSelect.addEventListener('change', onScanChange);
        scanIndexInput.addEventListener('change', onScanChange);
        prevScanBtn.addEventListener('click', () => {
             let val = parseInt(scanIndexInput.value);
             if (val > 0) { scanIndexInput.value = val - 1; onScanChange(); }
        });
        nextScanBtn.addEventListener('click', () => {
             let val = parseInt(scanIndexInput.value);
             let max = parseInt(scanIndexInput.max);
             if (val < max) { scanIndexInput.value = val + 1; onScanChange(); }
        });

        // Add Listener for Axis Map
        axisMapSelect.addEventListener('change', () => {
            updateUI();
            updateCubes(false);
            if (viewModeSelect.value === '2d') snapCamera();
        });

        inputScale.addEventListener('input', () => { autoScaleCheckbox.checked = false; updateCubes(false); });
        autoScaleCheckbox.addEventListener('change', () => updateCubes(false));
        forceCubicCheckbox.addEventListener('change', () => updateCubes(false));
        maxRatioInput.addEventListener('input', () => updateCubes(false));
        showOriginCheckbox.addEventListener('change', () => updateCubes(false));

        colorModeSelect.addEventListener('change', () => updateCubes(false)); 
        patternSelect.addEventListener('change', () => { dataLoadedFromFile = false; updateCubes(true); }); 
        inputDensity.addEventListener('input', () => { dataLoadedFromFile = false; updateCubes(true); }); 
        binaryGradientCheckbox.addEventListener('change', () => updateCubes(false));
        viewModeSelect.addEventListener('change', () => updateCubes(false));
        
        sliceAxisSelect.addEventListener('change', () => { updateUI(); updateCubes(false); snapCamera(); });
        prevSliceBtn.addEventListener('click', () => {
            let val = parseInt(sliceIndexInput.value);
            if (val > 0) { sliceIndexInput.value = val - 1; updateCubes(false); }
        });
        nextSliceBtn.addEventListener('click', () => {
            let val = parseInt(sliceIndexInput.value);
            let max = parseInt(sliceIndexInput.max);
            if (val < max) { sliceIndexInput.value = val + 1; updateCubes(false); }
        });
        sliceIndexInput.addEventListener('change', () => updateCubes(false)); 
        meanProjectionCheckbox.addEventListener('change', () => updateCubes(false));

        function updateColorsOnly() {
            if (!mesh) return;
            if ((meanProjectionCheckbox.checked && colorModeSelect.value === 'binary') || 
                (binaryGradientCheckbox.checked && colorModeSelect.value === 'binary')) {
                updateCubes(false);
                return;
            }
            updateCubes(false);
        }

        [inputContLow, inputContHigh, inputColor0, inputColor1].forEach(el => {
            el.addEventListener('input', updateColorsOnly);
        });

        snapCameraBtn.addEventListener('click', snapCamera);
        resetCamBtn.addEventListener('click', resetCamera);
        zoomInBtn.addEventListener('click', () => {
            const direction = new THREE.Vector3().copy(camera.position).sub(controls.target);
            direction.multiplyScalar(0.8);
            camera.position.copy(controls.target).add(direction);
            controls.update();
        });
        zoomOutBtn.addEventListener('click', () => {
            const direction = new THREE.Vector3().copy(camera.position).sub(controls.target);
            direction.multiplyScalar(1.25);
            camera.position.copy(controls.target).add(direction);
            controls.update();
        });
        exportSliceBtn.addEventListener('click', exportSlice);

        function exportSlice() {
            snapCamera();
            controls.update();
            const currentBackground = scene.background;
            const originalPixelRatio = renderer.getPixelRatio();
            
            // Use high resolution for export
            renderer.setPixelRatio(1);
            scene.background = null; // Transparent background
            renderer.render(scene, camera);
            
            // Get data URL immediately
            const dataURL = renderer.domElement.toDataURL('image/png');

            // Restore scene state
            scene.background = currentBackground;
            renderer.setPixelRatio(originalPixelRatio);
            renderer.render(scene, camera);

            // Process image for cropping
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                const w = canvas.width;
                const h = canvas.height;
                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;
                
                let minX = w, maxX = 0, minY = h, maxY = 0;
                let found = false;

                // Find Top (minY)
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (data[(y * w + x) * 4 + 3] > 0) {
                            minY = y;
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
                
                if (!found) { 
                    // Empty image fallback
                    minX = 0; maxX = w; minY = 0; maxY = h;
                } else {
                    // Find Bottom (maxY)
                    for (let y = h - 1; y >= minY; y--) {
                        for (let x = 0; x < w; x++) {
                            if (data[(y * w + x) * 4 + 3] > 0) {
                                maxY = y;
                                break;
                            }
                        }
                        if (maxY > 0) break;
                    }

                    // Find Left (minX) - scan only within Y bounds
                    found = false;
                    for (let x = 0; x < w; x++) {
                        for (let y = minY; y <= maxY; y++) {
                            if (data[(y * w + x) * 4 + 3] > 0) {
                                minX = x;
                                found = true;
                                break;
                            }
                        }
                        if (found) break;
                    }

                    // Find Right (maxX)
                    for (let x = w - 1; x >= minX; x--) {
                        for (let y = minY; y <= maxY; y++) {
                            if (data[(y * w + x) * 4 + 3] > 0) {
                                maxX = x;
                                break;
                            }
                        }
                        if (maxX > 0) break;
                    }
                }
                
                // Add Padding
                const padding = 50; 
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(w, maxX + padding);
                maxY = Math.min(h, maxY + padding);
                
                const cropW = maxX - minX;
                const cropH = maxY - minY;
                
                // Legend Settings
                const showLegend = colorModeSelect.value === 'binary';
                
                // Calculate Legend Dimensions first
                let legendW = 0;
                let legendH = 0;
                
                // Layout variables
                let fontSize = 24;
                let boxSize = 30;
                let gap = 15;
                let rowGap = 15;
                let legendPadding = 20;
                let margin = 20;
                
                if (showLegend) {
                    // Target total legend height â‰ˆ 1/5 of the image height
                    const targetHeight = cropH / 2;
                    
                    // Formula for Height: 2*padding + 2*boxSize + rowGap
                    // Ratios assumed: boxSize=F, padding=0.6F, rowGap=0.5F
                    // Total = 1.2F + 2F + 0.5F = 3.7F
                    // F = targetHeight / 3.7
                    
                    fontSize = Math.max(12, Math.round(targetHeight / 3.7));
                    boxSize = fontSize;
                    gap = Math.round(fontSize * 0.5);
                    rowGap = Math.round(fontSize * 0.5);
                    legendPadding = Math.round(fontSize * 0.6);
                    margin = Math.round(fontSize * 0.6); // Scale margin too

                    const tempCtx = document.createElement('canvas').getContext('2d'); // temp ctx for measuring
                    tempCtx.font = `bold ${fontSize}px "Segoe UI", sans-serif`;
                    const text0 = "Non-selected";
                    const text1 = "Selected";
                    const w0 = tempCtx.measureText(text0).width;
                    const w1 = tempCtx.measureText(text1).width;
                    const maxTextW = Math.max(w0, w1);
                    
                    legendW = legendPadding * 2 + boxSize + gap + maxTextW;
                    legendH = legendPadding * 2 + boxSize * 2 + rowGap; 
                }

                // Ensure canvas is at least big enough for legend if it's small
                const finalW = Math.max(cropW, showLegend ? legendW + margin * 2 : 0);
                const finalH = Math.max(cropH, showLegend ? legendH + margin * 2 : 0);

                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = finalW;
                finalCanvas.height = finalH;
                const finalCtx = finalCanvas.getContext('2d');
                
                // Fill background (optional, for transparency keep as is, or fill black for visibility)
                // finalCtx.fillStyle = '#1a1a1a';
                // finalCtx.fillRect(0, 0, finalW, finalH);

                // Draw cropped portion (centered)
                const drawX = (finalW - cropW) / 2;
                const drawY = (finalH - cropH) / 2;
                finalCtx.drawImage(canvas, minX, minY, cropW, cropH, drawX, drawY, cropW, cropH);
                
                // Draw Legend if Binary Mode
                if (showLegend) {
                    const c0 = inputColor0.value;
                    const c1 = inputColor1.value;
                    
                    finalCtx.font = `bold ${fontSize}px "Segoe UI", sans-serif`;
                    finalCtx.textBaseline = 'middle';
                    
                    const text0 = "Non-selected";
                    const text1 = "Selected";
                    
                    // Position: Top Right with margin
                    const lx = finalW - legendW - margin;
                    const ly = margin;
                    
                    // Legend Background
                    finalCtx.fillStyle = 'rgba(255, 242, 204, 0.65)';
                    finalCtx.strokeStyle = '#555';
                    finalCtx.lineWidth = Math.max(1, fontSize * 0.05); // Scale line width slightly
                    finalCtx.fillRect(lx, ly, legendW, legendH);
                    finalCtx.strokeRect(lx, ly, legendW, legendH);
                    
                    // Draw Items (Vertical Stack)
                    let currentY = ly + legendPadding + (boxSize / 2);
                    let currentX = lx + legendPadding;
                    
                    // Item 0
                    finalCtx.fillStyle = c0;
                    finalCtx.fillRect(currentX, currentY - boxSize/2, boxSize, boxSize);
                    finalCtx.strokeRect(currentX, currentY - boxSize/2, boxSize, boxSize);
                    
                    finalCtx.fillStyle = '#000000';
                    finalCtx.fillText(text0, currentX + boxSize + gap, currentY);
                    
                    currentY += boxSize + rowGap;
                    
                    // Item 1
                    finalCtx.fillStyle = c1;
                    finalCtx.fillRect(currentX, currentY - boxSize/2, boxSize, boxSize);
                    finalCtx.strokeRect(currentX, currentY - boxSize/2, boxSize, boxSize);
                    
                    finalCtx.fillStyle = '#000000';
                    finalCtx.fillText(text1, currentX + boxSize + gap, currentY);
                }

                // Download
                const axis = sliceAxisSelect.value;
                const idx = sliceIndexInput.value;
                const filename = `slice_${axis}_${idx}.png`;
                
                const link = document.createElement('a');
                link.download = filename;
                link.href = finalCanvas.toDataURL('image/png');
                link.click();
            };
            img.src = dataURL;
        }

        function snapCamera() {
            if (viewModeSelect.value !== '2d') return;
            const axis = sliceAxisSelect.value;
            
            // 1. Get visual dimensions (Global Max or Specific based on Scan Mode)
            let gA=0,gB=0,gC=0,gD=cubesConfig.length;
            cubesConfig.forEach(s=>{ gA=Math.max(gA,s.a); gB=Math.max(gB,s.b); gC=Math.max(gC,s.c); });
            const sAxis = scanAxisSelect.value;
            const scanIdx = parseInt(scanIndexInput.value) || 0;

            let baseDims = [];
            if(sAxis==='d') {
                const s = cubesConfig[scanIdx] || {a:1,b:1,c:1};
                baseDims = [s.a, s.b, s.c];
            }
            else if(sAxis==='a') baseDims=[gD, gB, gC];
            else if(sAxis==='b') baseDims=[gD, gA, gC];
            else if(sAxis==='c') baseDims=[gD, gA, gB];

            const P = getPermutation();
            const vDimX = baseDims[P[0]];
            const vDimY = baseDims[P[1]];
            const vDimZ = baseDims[P[2]];

            // 2. Calculate Steps (Spacing) to match updateCubes logic
            const constrainRatio = forceCubicCheckbox.checked;
            const maxRatioVal = parseFloat(maxRatioInput.value) || 10;
            let stepX = 1, stepY = 1, stepZ = 1;
            if (constrainRatio) {
                const maxDim = Math.max(vDimX, vDimY, vDimZ);
                const minAllowed = maxDim / maxRatioVal;
                if (vDimX < minAllowed) stepX = minAllowed / vDimX;
                if (vDimY < minAllowed) stepY = minAllowed / vDimY;
                if (vDimZ < minAllowed) stepZ = minAllowed / vDimZ;
            }

            // 3. Calculate Actual Visual Extents (Bounding Box)
            const scaleVal = parseFloat(inputScale.value) || 1;
            const sizeX = (vDimX > 0) ? (vDimX - 1) * stepX + (scaleVal * stepX) : 0;
            const sizeY = (vDimY > 0) ? (vDimY - 1) * stepY + (scaleVal * stepY) : 0;
            const sizeZ = (vDimZ > 0) ? (vDimZ - 1) * stepZ + (scaleVal * stepZ) : 0;

            // 4. Calculate Slice Center Offset
            const sliceIdx = parseInt(sliceIndexInput.value) || 0;
            let target = new THREE.Vector3(0,0,0);
            
            if (axis === 'x') {
                const offsetX = (vDimX - 1) / 2;
                target.x = (sliceIdx - offsetX) * stepX;
            } else if (axis === 'y') {
                const offsetY = (vDimY - 1) / 2;
                target.y = (sliceIdx - offsetY) * stepY;
            } else if (axis === 'z') {
                const offsetZ = (vDimZ - 1) / 2;
                target.z = (sliceIdx - offsetZ) * stepZ;
            }

            // 5. Calculate Fit Distance with Constant Padding
            const fov = camera.fov * (Math.PI / 180);
            const aspect = camera.aspect;
            const padding = 1.1; 
            
            const getFitDist = (w, h) => {
                const distV = (h / 2) / Math.tan(fov / 2);
                const distH = (w / 2) / (aspect * Math.tan(fov / 2));
                return Math.max(distV, distH) * padding;
            };

            // Set Camera Target
            controls.target.copy(target);
            
            // Logic: Enforce Width > Height (Landscape) while keeping Origin (0,0) at Top-Left
            if (axis === 'x') {
                // Plane YZ. Normal: W=Z, H=Y. Origin is Min Y, Min Z.
                let w = sizeZ; 
                let h = sizeY;
                
                if (h > w) {
                    // SWAP: H > W. View Landscape.
                    // To keep Origin TL: View from -X (Other Side), Up = -Z.
                    const dist = getFitDist(h, w); 
                    camera.position.set(target.x - dist, target.y, target.z);
                    camera.up.set(0, 0, -1);
                } else {
                    // Normal.
                    // To keep Origin TL: View from +X, Up = -Y.
                    const dist = getFitDist(w, h);
                    camera.position.set(target.x + dist, target.y, target.z);
                    camera.up.set(0, -1, 0);
                }
            } 
            else if (axis === 'y') {
                // Plane XZ. Normal: W=X, H=Z. Origin is Min X, Min Z.
                let w = sizeX; 
                let h = sizeZ;
                
                if (h > w) {
                    // SWAP: H > W. View Landscape.
                    // To keep Origin TL: View from -Y (Bottom), Up = -X.
                    const dist = getFitDist(h, w);
                    camera.position.set(target.x, target.y - dist, target.z);
                    camera.up.set(-1, 0, 0);
                } else {
                    // Normal.
                    // To keep Origin TL: View from +Y, Up = -Z.
                    const dist = getFitDist(w, h);
                    camera.position.set(target.x, target.y + dist, target.z);
                    camera.up.set(0, 0, -1); 
                }
            } 
            else if (axis === 'z') {
                // Plane XY. Normal: W=X, H=Y. Origin is Min X, Min Y.
                let w = sizeX; 
                let h = sizeY;
                
                if (h > w) {
                    // SWAP: H > W. View Landscape.
                    // To keep Origin TL: View from -Z (Back Side), Up = -X.
                    const dist = getFitDist(h, w);
                    camera.position.set(target.x, target.y, target.z - dist);
                    camera.up.set(-1, 0, 0); 
                } else {
                    // Normal.
                    // To keep Origin TL: View from +Z (Front), Up = -Y.
                    const dist = getFitDist(w, h);
                    camera.position.set(target.x, target.y, target.z + dist); // Corrected distance direction
                    camera.up.set(0, -1, 0); 
                }
            }
            
            camera.lookAt(target);
            controls.update();
        }

        function resetCamera() {
            // 1. Get visual dimensions (Current View)
            let gA=0,gB=0,gC=0,gD=cubesConfig.length;
            cubesConfig.forEach(s=>{ gA=Math.max(gA,s.a); gB=Math.max(gB,s.b); gC=Math.max(gC,s.c); });
            const sAxis = scanAxisSelect.value;
            const scanIdx = parseInt(scanIndexInput.value) || 0;

            let baseDims = [];
            if(sAxis==='d') {
                // Use current slice for tight fit
                const s = cubesConfig[scanIdx] || {a:1,b:1,c:1};
                baseDims = [s.a, s.b, s.c];
            }
            else if(sAxis==='a') baseDims=[gD, gB, gC];
            else if(sAxis==='b') baseDims=[gD, gA, gC];
            else if(sAxis==='c') baseDims=[gD, gA, gB];
            
            const P = getPermutation();
            const vDimX = baseDims[P[0]];
            const vDimY = baseDims[P[1]];
            const vDimZ = baseDims[P[2]];

            // 2. Calculate Steps (Spacing)
            const constrainRatio = forceCubicCheckbox.checked;
            const maxRatioVal = parseFloat(maxRatioInput.value) || 10;
            let stepX = 1, stepY = 1, stepZ = 1;
            if (constrainRatio) {
                const maxDim = Math.max(vDimX, vDimY, vDimZ);
                const minAllowed = maxDim / maxRatioVal;
                if (vDimX < minAllowed) stepX = minAllowed / vDimX;
                if (vDimY < minAllowed) stepY = minAllowed / vDimY;
                if (vDimZ < minAllowed) stepZ = minAllowed / vDimZ;
            }

            // 3. Calculate Actual Visual Extents (Bounding Box)
            const scaleVal = parseFloat(inputScale.value) || 1;
            const sizeX = (vDimX > 0) ? (vDimX - 1) * stepX + (scaleVal * stepX) : 0;
            const sizeY = (vDimY > 0) ? (vDimY - 1) * stepY + (scaleVal * stepY) : 0;
            const sizeZ = (vDimZ > 0) ? (vDimZ - 1) * stepZ + (scaleVal * stepZ) : 0;

            // 4. Calculate Distance
            // Center is (0,0,0). We want to fit the bounding sphere.
            const radius = Math.sqrt(sizeX*sizeX + sizeY*sizeY + sizeZ*sizeZ) / 2;
            
            const fov = camera.fov * (Math.PI / 180);
            const padding = 1.2; // 20% padding
            
            // Distance from center needed to fit the radius sphere
            // Using sin(fov/2) ensures the sphere fits within the camera cone
            let distToCenter = (radius * padding) / Math.sin(fov / 2);
            
            // Adjust for diagonal camera position (d, d, d)
            // Distance from origin to (d,d,d) is d * sqrt(3)
            const d = distToCenter / Math.sqrt(3);

            controls.target.set(0, 0, 0);
            camera.up.set(0, 1, 0);
            camera.position.set(d, d, d);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        // --- FILE LOADING & COMMON PARSING ---
        function loadCubeData(json) {
            if (!Array.isArray(json)) throw new Error("Root must be array");
            
            cubesConfig = [];
            json.forEach(slice => {
                if (!slice.shape || slice.shape.length !== 3) throw new Error("Invalid shape");
                const [a, b, c] = slice.shape;
                const len = a*b*c;
                
                let rawData = slice.data;
                if (Array.isArray(rawData)) {
                    rawData = rawData.flat(Infinity);
                }

                let arr = new Float32Array(len);
                if (rawData && rawData.length >= len) {
                    for(let i=0; i<len; i++) arr[i] = Number(rawData[i]);
                } else {
                     console.warn("Data length mismatch for slice (filled with 0)", slice);
                }
                cubesConfig.push({ a, b, c, data: arr });
            });
            
            inputD.value = cubesConfig.length;
            dataLoadedFromFile = true; 
            
            scanAxisSelect.value = 'd';
            scanIndexInput.value = 0;
            
            if (scanAxisSelect.value === 'd') {
                 const w = parseInt(scanIndexInput.value) || 0;
                 if (cubesConfig[w]) {
                     inputA.value = cubesConfig[w].a;
                     inputB.value = cubesConfig[w].b;
                     inputC.value = cubesConfig[w].c;
                 }
            }
            updateCubes(false);
            if (viewModeSelect.value === '2d') {
                snapCamera();
            }
        }

        dlTemplateBtn.addEventListener('click', () => {
            const template = [
                { shape: [3, 2, 2], data: [0,1,0,1,1,1, 0,0,0,0,0,0] },
                { shape: [2, 2, 2], data: [1,0,1,0, 1,1,1,1] }
            ];
            const blob = new Blob([JSON.stringify(template, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'cube_template.json';
            link.click();
        });

        chooseFileBtn.addEventListener('click', () => {
            fileInput.click();
        });

        resetDataBtn.addEventListener('click', () => {
            dataLoadedFromFile = false;
            fileNameDisplay.innerText = "No file selected";
            updateCubes(true);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            fileNameDisplay.innerText = file.name;

            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const json = JSON.parse(evt.target.result);
                    loadCubeData(json);
                } catch(err) {
                    alert("Error parsing JSON: " + err.message);
                    fileNameDisplay.innerText = "Error loading file";
                }
            };
            reader.readAsText(file);
        });

        loadUrlBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if(!url) return;
            fileNameDisplay.innerText = "Loading URL...";
            
            fetch(url)
                .then(res => {
                    if(!res.ok) throw new Error(res.statusText);
                    return res.json();
                })
                .then(json => {
                    loadCubeData(json);
                    fileNameDisplay.innerText = "Loaded: " + url;
                })
                .catch(err => {
                    alert("Fetch Error: " + err.message);
                    fileNameDisplay.innerText = "Error loading URL";
                });
        });

        window.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropOverlay.classList.add('active');
        });

        window.addEventListener('dragleave', (e) => {
            if (e.relatedTarget === null) {
                dropOverlay.classList.remove('active');
            }
        });

        window.addEventListener('drop', (e) => {
            e.preventDefault();
            dropOverlay.classList.remove('active');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.json')) {
                fileNameDisplay.innerText = file.name;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const json = JSON.parse(evt.target.result);
                        loadCubeData(json);
                    } catch(err) { alert("Error parsing JSON: " + err.message); }
                };
                reader.readAsText(file);
            } else {
                alert("Please drop a valid .json file");
            }
        });

        updateCubes(true);

        controls.addEventListener('start', () => { controls.autoRotate = false; });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>